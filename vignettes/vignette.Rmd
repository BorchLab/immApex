---
title: Welcome to Apex
author: 
- name: Nick Borcherding
  email: ncborch@gmail.com
  affiliation: Washington University in St. Louis, School of Medicine, St. Louis, MO, USA
date: "April 26, 2024"
output:
  BiocStyle::html_document:
    toc_float: true
package: Trex
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Running Apex}
  %\usepackage[UTF-8]{inputenc}
---

```{r, echo=FALSE, results="hide", message=FALSE}
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
library(BiocStyle)
```

# Introduction

Apex is meant to serve as an API for deep learning models based on immune receptor sequencing. These collection of functions serve to extract or generate amino acid sequences and then preparing the sequences for deep learning tasks through Keras. Although the tools here are created for immune receptor sequences, they will work more generally for nucleotide or amino acid sequences of any kind. 

## Load Libraries

```{r}
suppressMessages(library(Apex))
suppressMessages(library(keras))
suppressMessages(library(scRepertoire))
```

****************

# Getting and Manipulating Sequences

## Generate.sequences

A quick way to get started with testing the model code would be to generate synthetic sequences. ```generate.sequences()``` can also be used to generate realistic noise for generative adversarial networks. 

Parameters for ```generate.sequences()```

* **prefix.motif** Add defined amino acid sequence to the start of the generated sequences.
* **suffix.motif** Add defined amino acid sequence to the end of the generated sequences
number.of.sequences Number of sequences to generate
* **min.length** Minimum length of the final sequence (will be adjusted if incongruent with prefix.motif/suffix.motif)
* **max.length** Maximum length of the final sequence
* **sequence.dictionary** The letters to use in sequence generation (default are all amino acids)

```{r}
sequences <- generate.sequences(prefix.motif = "CAS",
                                suffix.motif = "YF",
                                number.of.sequences = 1000,
                                min.length = 8,
                                max.length = 16)
head(sequences)
```

If instead of amino acides, we want to look at nucleotide sequences, we just need to change the **sequence.dictionary**.

```{r}
nucleotide.sequences <- generate.sequences(number.of.sequences = 1000,
                                           min.length = 8,
                                           max.length = 16, 
                                           sequence.dictionary = c("A", "C", "T", "G"))
head(nucleotide.sequences)
```

## Mutate.sequences

A common approach is to take sequences and mutate them randomly or at specific intervals. This can be particularly helpful if we have a low number of sequences or want to test a model for accuracy given new, altered sequences. ```mutate.sequences()``` allows us to tune the type of mutation, where along the sequences to introduce the mutation, and the overall number of mutations.

Parameters for ```mutate.sequences()```

* **input.sequences** The amino acid or nucleotide sequences to use
* **n.sequences** The number of mutated sequences to return per input.sequence
* **mutation.rate** The rate of mutations to introduce into sequences
* **position.start** The starting position to mutate along the sequence.Default NULL will start the random mutations at position 1.
* **position.end** The ending position to mutate along the sequence.Default NULL will end the random mutations at the last position.
* **sequence.dictionary** The letters to use in sequence mutation (default are all amino acids)

```{r}
mutated.sequences <- mutate.sequences(sequences, 
                                      n.sequence = 1,
                                      position.start = 3,                                  
                                      position.end = 8)
head(sequences)
head(mutated.sequences)
```
# Encoders

## One.hot.encoder

One hot encoding of amino acid or nucleotide sequences is a common method to transform sequences into numeric matrices compatible with kera (or other workflows).

Parameters for ```one.hot.encoder()```

* **input.sequences** The amino acid or nucleotide sequences to use
* **max.length** Additional length to pad, NULL will pad sequences to the max length of input.sequences
* **convert.to.matrix** Return a matrix (**TRUE**) or a 3D array (**FALSE**)
* **sequence.dictionary** The letters to use in encoding (default are all amino acids + NA value)

```{r}
sequence.matrix <- one.hot.encoder(input.sequences =  c(sequences, mutated.sequences), 
                                   convert.to.matrix = TRUE)
head(sequence.matrix[,1:20])
```

## Property.encoder

An alternative to one hot encoding is to transform the sequences into an array/matrix of numerical values using amino acid properties. These properties are largely based on dimensional reduction strategies, but it is important to know the assumptions for each approach (links to original work below). **Important to note** this is the only encoding strategy that is specific for amino acids. 

**method.to.use**  

* atchleyFactors - \href{https://pubmed.ncbi.nlm.nih.gov/15851683/}{citation}).
* crucianiProperties - \href{https://analyticalsciencejournals.onlinelibrary.wiley.com/doi/abs/10.1002/cem.856}{citation}).
* FASGAI - \href{https://pubmed.ncbi.nlm.nih.gov/18318694/}).
* kideraFactors - \href{https://link.springer.com/article/10.1007/BF01025492}{citation}).
* MSWHIM - \href{https://pubs.acs.org/doi/10.1021/ci980211b}{citation}).
* ProtFP - \href{https://pubmed.ncbi.nlm.nih.gov/24059694/}{citation}).
* stScales - \href{https://pubmed.ncbi.nlm.nih.gov/19373543/}{citation}).
* tScales - \href{https://www.sciencedirect.com/science/article/abs/pii/S0022286006006314}{citation}).
* VHSE - \href{https://pubmed.ncbi.nlm.nih.gov/15895431/}{citation}).
* zScales - \href{https://pubmed.ncbi.nlm.nih.gov/9651153/}{citation}).


```{r}
property.matrix <- property.encoder(input.sequences =  c(sequences, mutated.sequences), 
                                    method.to.use = "FASGAI",
                                    convert.to.matrix = TRUE)

head(property.matrix[,1:20])
```

## Tokenize.sequences

Another approach to transforming a sequence into numerical values is tokenizing it into numbers. This is a common approach for recurrent neural networks where one letter correspond to a single integer. In addition, we can add start and stop tokens to our original sequences in order to differentiate between the beginning and end of the sequences. 

Parameters for ```tokenize.sequences()```

* **add.startstop** Add start and stop tokens to the sequence
* **start.token** The character to use for the start token
* **stop.token** The character to use for the stop token
* **max.length** Additional length to pad, NULL will pad sequences to the max length of input.sequences
* **convert.to.matrix** Return a matrix (**TRUE**) or a vector (**FALSE**)


```{r}
token.matrix <- tokenize.sequences(input.sequences =  c(sequences, mutated.sequences), 
                                   add.startstop = TRUE,
                                   start.token = "!",
                                   stop.token = "^", 
                                   convert.to.matrix = TRUE)
head(token.matrix[,1:18])
```
## Positional.encoder

```{r}
positional.matrix <- positional.encoder(number.of.sequences = length(c(sequences, mutated_sequences)),
                                        latent.dims = 40)
```


***
# Conclusion

This has been a general overview of the capabilities of Apex for processing immune receptor sequences and making deep learning models. If you have any questions, comments, or suggestions, feel free to visit the github repository or [email me](mailto:ncborch@gmail.com).

## Session Info

```{r}
sessionInfo()
```
