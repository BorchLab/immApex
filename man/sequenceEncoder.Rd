% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sequenceEncoder.R
\name{sequenceEncoder}
\alias{sequenceEncoder}
\alias{onehotEncoder}
\alias{propertyEncoder}
\title{Universal Amino-acid Sequence Encoder}
\usage{
sequenceEncoder(
  sequences,
  mode = c("onehot", "property"),
  property.set = NULL,
  property.matrix = NULL,
  sequence.dictionary = amino.acids,
  pad.symbol = ".",
  summary.fun = "",
  max.length = NULL,
  nthreads = parallel::detectCores(),
  verbose = TRUE
)

onehotEncoder(..., mode = "onehot")

propertyEncoder(..., mode = "property")
}
\arguments{
\item{sequences}{`character` vector. Amino-acid sequences (uppercase
single-letter code).  Gaps or unknown symbols are replaced by `pad.symbol`.}

\item{mode}{Either `"onehot"` (default) or `"property"`.}

\item{property.set}{*Optional* `character` vector of property names to
extract from \pkg{Peptides} (ignored in `"onehot"` mode).  Ignored if 
`property.matrix` is supplied.}

\item{property.matrix}{*Optional* numeric matrix (`20 × P`). Overrides 
`property.set`.}

\item{sequence.dictionary}{Character vector of the amino-acid alphabet
(default = 20 standard residues). The order defines the row order of 
`property.matrix`.}

\item{pad.symbol}{Single character used for padding / unknowns (default 
`"."`).  If not already in `sequence.dictionary`, it is appended internally.}

\item{summary.fun}{For property mode only: currently `"mean"` or `""`
(empty string) for no summary.  When `"mean"`, the computes the per-sequence mean across
positions and returns it as an extra element `summary`.}

\item{max.length}{Positive integer. Sequences longer than this are
truncated; shorter ones are right-padded with `pad.symbol`. If `NULL` 
(default) the longest input sequence sets the maximum.}

\item{nthreads}{Number of threads to request (passed to the C++ back-end).
Honoured only when the package is compiled with OpenMP; otherwise silently 
coerced to `1`.  Default = `parallel::detectCores()`.}

\item{verbose}{Logical. If `TRUE` (default) prints a short progress message.}
}
\value{
A named `list` with at least two elements  
\describe{
  \item{`cube`}{Numeric array with dimensions  
                `c(depth, max.length, length(sequences))`.  
                Depth = *sequence.dictionary size* in `"onehot"` mode, or
                *number of property scales* in `"property"` mode.}
  \item{`flattened`}{Numeric matrix, `length(sequences)` rows by
                     `depth × max.length` columns.}
  \item{`summary`}{(Only when `summary.fun != ""`) Numeric matrix,
                  `length(sequences) × depth`, containing the requested
                  statistic.}
  \item{`sequence.dictionary`, `pad_token`, `threads`}{Metadata echoed from the call.}
}
}
\description{
`sequenceEncoder()` is a high-level R wrapper around the low-level
`encodeSequences_cpp()` engine (see `?encodeSequences_cpp`).  It converts a
character vector of amino-acid sequences into either  
(1) **one-hot** representations, or  
(2) **property-based** representations (e.g. hydropathy, charge, Atchley
factors)
}
\details{
The function performs basic argument validation, constructs (or accepts) a
property matrix when `mode = "property"`, and then calls the C++ back-end.
The resulting list contains a 3-D array (`cube`) and a flattened 2-D matrix
(`flattened`) that can feed directly into downstream machine-learning
pipelines (autoencoders, random forests, etc.).
}
\section{Property mode}{

If you supply `property.matrix` directly, it **must** be a numeric matrix
whose **rows correspond to the 20 canonical amino acids in the order of
`sequence.dictionary`** and whose columns are the property scales.  This keeps the
function free of mandatory heavy packages.  

If you would rather reference property names (e.g. `"hydrophobicity",
"charge"`), pass them via `property.set`.  If the \pkg{Peptides} package is
installed, `sequenceEncoder()` will look them up in `Peptides:::AAdata`.
Otherwise an informative error is thrown.
}

\examples{
aa <- c("CARDRST", "YYYGMD", "ACACACAC")
enc <- sequenceEncoder(aa, 
                       mode = "onehot")

prop <- sequenceEncoder(aa,
                        mode = "property",
                        property.set = c("hydrophobicity", "charge"),
                        summary.fun  = "mean")


}
